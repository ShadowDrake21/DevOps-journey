I have started from the theory to the first part of the day "Advanced Bash Fundamentals":
- Local vs global variables: https://www.geeksforgeeks.org/linux-unix/batch-script-local-vs-global-variables/;
- $?, exit, return, and why every automation script must check exit codes (generated by ChatGPT);
- Debugging with bash -x (generated by ChatGPT);
- How scripts get executed (PATH, shebangs): https://unix.stackexchange.com/questions/87560/does-the-shebang-determine-the-shell-which-runs-the-script;
- Why idempotence matters in DevOps (script should be repeatable and safe) (generated by ChatGPT).

Next I have completed Challenge 1 - "Safety Guard Script":
It does:
- take one argument: a directory path;
- check if it exist;
- if not, create it and log as entry in /tmp/dirlog.txt;
- return 0 if success, 1 if failure;
- print colored output of result.

The theory for the Part 2 "Logic, Loops and Automation":
- https://www.w3schools.com/bash/bash_loops.php;
- https://linuxize.com/post/bash-arrays/;
- https://medium.com/@aiinstructor/bash-scripting-functions-for-modularity-and-reusability-3d60a33976cc.

Next I have completed Challenge 2 - "Resource Tracker":
It does:
- check top 5 CPU-consuming processes;
- check memory usage;
- log output to log file;
- add a header with date/time and hostname;
- send both stdout and stder in the log;
- use a function to pring section headers;
- use debugging tools.

Next load of theory fpr the Part 3 "Redirections, Pipes and Error Handling":
- Null sink (/dev/null) and silent execution (generated by ChatGPT);
- Practical use of tee to log and print simultaneously (generated by ChatGPT).

Additional materials:
- https://gist.github.com/mohanpedala/1e2ff5661761d3abd0385e8223e16425?permalink_comment_id=3935570.

Next I have completed Challenge 3 - "Smart Backup":
It does:
- take two arguments: source and destination;
- check if source exists;
- create destination if missing;
- archive source to destination;
- log output to /var/log/backup_activity.log;
- if any step fails, print an error and exit non-zero;
- use set -euo pipefail.

The last thing I have done here is to create "real-world" automation pipeline manually - full_day_2_1_integration.sh.
